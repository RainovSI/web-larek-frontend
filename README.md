# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/styles/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

## Архитектура

Архитектура данного проекта основана на паттерне MVP (Model-View-Presenter)

## Описание структур данных
- Интерфейс ProductDetails — определяет атрибуты одного товара. Массив ProductDetails[] представляет каталог товаров.
- Интерфейс OrderResponse — характеризует ответ сервера на успешное оформление заказа.
- Интерфейс OrderData — описывает структуру данных, отправляемых серверу при оформлении заказа.
- Интерфейс ApplicationState — содержит данные каталога, корзины и текущего заказа.

## Модели данных

### Уровень MODEL:
(Этот уровень обеспечивает связь данных между сервером и пользовательским интерфейсом)

#### Класс EntityModel
Абстрактный класс, служащий основой для создания объектов моделей, которые хранят и управляют данными в приложении. Гарантирует, что все производные модели будут соответствовать определенному набору правил и структур.

Конструктор:
- Обычно отсутствует, так как не создает объект напрямую, но определяет структуру и поведение для наследуемых классов.

Методы:
- Определяет абстрактный интерфейс, состоящий из стандартного набора методов и свойств, которые будут реализованы в подклассах.

#### Класс ProductDetailsModel
Специализированный класс, расширяющий EntityModel, используется для описания данных о товаре включая, но не ограничиваясь, информацией о названии, цене, деталях.

Конструктор:
- ProductDetailsModel(data: ProductData) - принимает данные о продукте, которые включают все необходимые свойства товара, для их последующего хранения в модели.

Методы:
- getDetail(name: string): any - возвращает значение детали товара по её имени.
- setDetail(name: string, value: any): void - задает или обновляет значение детали товара.

#### Класс ApplicationStateModel
Отвечает за управление состоянием приложения, сохраняет и обновляет данные о каталоге товаров, корзине и текущих заказах.

Конструктор:
- ApplicationStateModel(initialState: State) - принимает начальное состояние приложения, включая списки товаров, содержимое корзины и историю заказов.

Методы:
- addInBasket(item: ProductDetailsModel): void - добавляет товар в корзину.
- removeFromBasket(itemId: string): void - удаляет товар из корзины по его идентификатору.
- clearOrder(): void - удаляет все данные текущего заказа.
- clearBasket(): void - полностью очищает корзину.
- getTotal(): number - возвращает общую стоимость товаров в корзине.
- setCatalog(newCatalog: ProductDetailsModel[]): void - устанавливает новый текущий каталог товаров.
- checkBasket(itemId: string): boolean - проверяет наличие товара в корзине.
- setOrder(orderData: OrderData): void - сохраняет данные заказа.
- setPayment(paymentInfo: PaymentInfo): void - устанавливает информацию о платеже.
- setAddress(addressDetails: AddressDetails): void - задает адрес доставки.
- setEmail(email: string): void - сохраняет электронную почту пользователя для заказа.
- setPhone(phone: string): void - устанавливает контактный номер телефона пользователя.
- validateOrder(): boolean - проверяет правильность данных заказа перед его оформлением.
- validateOrderForm(): boolean - валидирует данные формы заказа на корректность ввода.

### Уровень VIEW:
(Этот уровень отвечает за визуализацию интерфейса пользователя)

#### `UIBaseComponent<T>`
Абстрактный базовый класс, необходимый для создания компонентов пользовательского интерфейса. Обеспечивает общие функции для управления поведением и внешним видом DOM элементов. Служит базой для всех классов представления.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, в который будет встроен компонент.

Методы:
- `toggleClass(className: string, condition: boolean)`: Добавляет или удаляет класс элемента в зависимости от условия.
- `setText(element: HTMLElement, text: string)`: Устанавливает текст для элемента.
- `setImage(element: HTMLImageElement, src: string, alt?: string)`: Устанавливает изображение и альтернативный текст для элемента `img`.
- `setDisabled(element: HTMLElement, disabled: boolean)`: Меняет атрибут `disabled` элемента.
- `setHidden(element: HTMLElement, hidden: boolean)`: Меняет видимость элемента, делая его невидимым.
- `setVisible(element: HTMLElement, visible: boolean)`: Меняет видимость элемента, делая его видимым.
- `render(data?: T)`: Отображает компонент, используя предоставленные данные.

#### `ProductCard`
Компонент для отображения информации о продукте. Включает функциональные возможности для установки заголовка, описания, изображения и цены продукта.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, в который компонент будет отображаться.

Методы:
- `setTitle(title: string)`: Устанавливает заголовок продукта.
- `setDescription(description: string)`: Устанавливает описание продукта.
- `setImage(src: string, alt?: string)`: Устанавливает изображение продукта с альтернативным текстом.
- `setPrice(price: number | string)`: Устанавливает цену продукта. Если цена не указана, автоматически деактивирует кнопку покупки.
- `setCategory(category: string)`: Задает категорию продукта, применяя класс для стилизации.
- `render()`: Отрисовывает карточку продукта в контейнер.

#### `BasketCard`
Компонент для визуализации отдельного товара в корзине покупателя.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, где будет отображаться карточка товара.

Методы:
- `setTitle(title: string)`: Задает название товара.
- `setIndex(index: number)`: Устанавливает порядковый номер товара в списке.
- `setPrice(price: number)`: Устанавливает цену товара.
- `render()`: Создает представление карточки товара в корзине.

#### `Basket`
Компонент для отображения общего содержимого корзины покупателя.

Конструктор:

- `container` (`HTMLElement`): DOM-элемент, который будет содержать корзину.

Методы:
- `render()`: Отображает содержимое корзины.

#### `MainPage`
Компонент для отображения основной страницы магазина. Управляет показом корзины, каталога товаров и возможностью блокировки скролла страницы.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, где будет отображаться основная страница.

Методы:
- `setCounter(count: number)`: Устанавливает количество товаров в корзине.
- `setCatalog(products: ProductDetails[])`: Показывает перечень доступных продуктов.
- `setLocked(locked: boolean)`: Блокирует прокрутку страницы.
- `render()`: Отрисовывает основную страницу веб-сайта.

#### `Modal`
Компонент для создания и управления модальными окнами.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, где будет отображаться модальное окно.

Методы:
- `setContent(content: HTMLElement | string)`: Устанавливает содержимое модального окна.
- `open()`: Открывает модальное окно.
- `close()`: Закрывает модальное окно.
- `render()`: Генерирует разметку модального окна и активирует его отображение.

#### `ValidationForm`
Компонент для реализации функциональности валидации форм.

Конструктор принимает:
- `container` (`HTMLElement`): DOM-элемент, где будет отображаться форма валидации.

Методы:
- `setValid(valid: boolean)`: Активирует или деактивирует кнопку отправки формы, в зависимости от прохождения валидации.
- `setErrors(errors: string[])`: Отображает ошибки валидации.

#### DeliveryOrder
Компонент, отвечающий за отображение интерактивной формы с выбором адреса доставки и способа оплаты. Позволяет пользователю ввести и подтвердить информацию, необходимую для доставки заказа.

Конструктор принимает:
- container (HTMLElement): DOM-элемент, в который будет встроена форма доставки.

Методы:
- setClass(className: string, condition: boolean): Добавляет или удаляет CSS класс у компонента в зависимости от условия.
- setAddress(address: string): Устанавливает или обновляет поле адреса доставки в форме.
- render(): Отображает форму доставки, предоставляя поля ввода для адреса и способа оплаты.

#### UserContacts
Компонент для представления и ввода контактных данных пользователя, таких как номер телефона и адрес электронной почты. Это позволяет пользователю удобно вносить и изменять свои контактные данные в процессе оформления заказа или в настройках профиля.

Конструктор принимает:
- container (HTMLElement): DOM-элемент, в который встраивается форма контактов пользователя.

Методы:
- setPhone(phone: string): Задает номер телефона пользователя в соответствующее поле формы.
- setEmail(email: string): Задает адрес электронной почты пользователя в соответствующее поле формы.
- render(): Создает и отображает форму для ввода контактных данных, такие как номер телефона и e-mail.

#### SuccessOrder
Компонент, который отображает уведомление о том, что заказ успешно оформлен. Это дает пользователю подтверждение о завершении процесса покупки и может включать дополнительные инструкции или информацию о следующих шагах.

Конструктор принимает:
- container (HTMLElement): DOM-элемент, в который будет встроено уведомление о успехе.

Методы:
- render(): Выводит уведомление с сообщением о успешном оформлении заказа и, при необходимости, дополнительной информацией для пользователя.

### Уровень PRESENTER:

#### Класс EventManager
Класс EventManager служит центральным диспетчером для управления событиями внутри приложения. Он позволяет компонентам подписываться на события, отписываться от них и инициировать новые, упрощая коммуникацию между различными частями системы.

Конструктор:
- constructor() - Конструктор класса EventManager не принимает параметров.

Методы:
- on(event: string, callback: Function): void - Подписывает функцию на событие.
- off(event: string, callback: Function): void - Отписывает функцию от события.
- triggerEvent(event: string, ...args: any[]): void - Инициирует событие, вызывая все подписанные функции-обработчики.
- onAll(callbacks: {[event: string]: Function}): void - Подписывает функции на все заданные в объекте события.
- offAll(callbacks: {[event: string]: Function}): void - Отписывает функции от всех заданных в объекте событий.

#### Класс Api
Базовый класс Api предназначен для инкапсуляции логики HTTP-взаимодействия с сервером. От этого класса наследуются другие классы, реализующие специфичные для определенного типа данных запросы.

Конструктор:
- constructor(baseURL: string) - Принимает базовый URL сервера, с которым будет осуществляться взаимодействие.

Методы:
- get(path: string, params?: object): Promise<any> - Выполняет GET-запрос к указанному пути относительно baseURL, возможно с параметрами.
- post(path: string, body: object): Promise<any> - Выполняет POST-запрос с телом запроса к указанному пути относительно baseURL.
- handleResponse(response: Response): Promise<any> - Обрабатывает полученный ответ от сервера.

#### Класс ProductsAPI
ProductsAPI является специализированным потомком класса Api, предназначенным для работы с товарами. Он обеспечивает взаимодействие с конечными точками API, относящимися к продуктам, и реализует действия, связанные с получением списка товаров, информации о товаре и отправкой заказа.

Конструктор:
- Конструктор наследуется от класса Api и может принимать baseURL для инициализации основных параметров API.

Методы:
- getProductsList(): Promise<ProductDetails[]> - Получает список всех товаров c сервера.
- getProductItem(productId: string): Promise<ProductDetails> - Получает информацию о конкретном товаре по его идентификатору.
- submitOrder(orderData: Order): Promise<any> - Отправляет данные заказа на сервер и возвращает его результат. 

## Об архитектуре

Архитектура данного проекта строится на основе принципов модели MVP (Model-View-Presenter), адаптированных для работы в веб-приложении. В такой архитектуре ключевую роль играет централизованное управление состоянием и взаимодействием через событийно-ориентированную модель.
Такая структура обеспечивает ряд преимуществ: четкое разделение ответственности между компонентами, гибкость в управлении состоянием, и удобство в тестировании всего приложения благодаря изоляции бизнес-логики от пользовательского интерфейса и обратной связи.